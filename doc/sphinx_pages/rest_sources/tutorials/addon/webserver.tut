
GUIs with the Shark Web Server
==============================

.. note::
    This tutorial is a stub. Its code does not compile yet; actually
    it requires quite a few changes to the web server itself.
    I just wanted this to be in the repository before I go on holidays.


This tutorial is on the web-server add-on component for the Shark
Library.

Shark is a machine learning library. As such it is not coupled to
a graphical user interface (GUI) system. This is a plus in most
situations, since this also means that Shark does not *depend* on a
specific GUI toolkit.
However, sometimes it can be tremendously helpful to visualize data
and results, and sometimes we may even need interactive control: in
other words, we need a GUI.

There are different ways to achieve this, but only few of them provide
a platform independent solution with minimal dependencies on third party
components. A simple option is to write out static results files, e.g.,
postscript diagrams or jpeg images. This can be cumbersome, and a proper
GUI is surely a more powerful option. It is one of our design principles
that we do not want Shark to depend on a huge GUI toolkit like Qt. This
is simply because Qt is a beast of a dependency. Instead we have decided
for a completely platform independent, lightweight solution: we have
equipped the Shark library with the necessary infrastructure for a
browser-based GUI.

This is where the web-server comes into play. It is the core component
for browser-based GUI and visualization capabilities. Simply link the
web-server add-on into your project, write your own request handlers
(this is where the actual work is done), wrap it into html (and if you
like add some javascript), and fire up a web browser that opens the
web GUI with a single C++ call.


Download and Installation
-------------------------

The Shark web-server add-on component is co-located with the core
library. It can be obtained directly from the subversion repository::

  svn co http://svn.code.sf.net/p/shark-project/code/trunk/add-on

The usual cmake/make procedure should build the web server add-on.
The result is a library called `shark_webserver`.


Overview
--------

The Shark web-server is as plain and simple as it gets. Checking out its
code base reveals that it consists only of a hand full of files. It is
not a fully fledged http server for production web hosting. It is
designed for ease of use and maintainability.

.. warning::
    The Shark web server is not intended for use on the world wide web.
    It is not designed to be particularly secure against any types of
    hacker attacks. Quite in contrast, any such security is missing! By
    default it is therefore limited to connections from a local client.
    This is exactly what is needed for a web-based GUI.


The web-server core code does not depend on Shark in any way. All it does
is to maintain a number of socket connections, to parse http requests,
and to deliver content. Http replies are generated by so-called request
handlers. The default request handler interprets the request as a file
name and delivers the addressed file if it exists. This handler does not
interact with Shark or your Shark-based program at all. Obviously, a
real GUI application will have to go beyond this. The connection to the
C++ application is realized through a custom request handler.

In general, creating a browser-based GUI has two parts. On the client
side some html and maybe javascript needs to be implemented, possibly
with the help of a javascript toolkit. On the server side some data
needs to be made available on request, and this happens inside a
specialized request handler. The Shark-based C++ application implements
the handler(s) and then invokes a single command to fire up the browser,
pointing to the GUI website. That's it.


A Minimal Example
-----------------

The following is a minimal example of a web server setup. First it
creates and starts an http server with a default request handler. The
server is listening on TCP/IP port 8888 (any port will do). Then the
program opens the website `http://127.0.0.1:8888/index.html` in the
default browser. Finally it waits for the user to stop the program::

  #include <SharkWebserver.h>
  #include <boost/thread/thread.hpp>

  using namespace shark;

  int main( int argc, char ** argv ) {
    HttpServer httpServer;
    httpServer.registerHandler(new FileHandler(boost::filesystem::initial_path()));
    httpServer.run(8888);

    openBrowser("http://127.0.0.1:8888/index.html");

    while (true) boost::this_thread::sleep( boost::posix_time::seconds(1) );
  }


The current directory becomes the root directory of the web server.
This means that the file `index.html` is assumed to exist in the
current directory. This file, as well as all other files possibly
references therein (such as css and javascript files as well as linked
pages) are loaded by the request handler from disk and are happily sent
out to the browser. Note that this behavior is a major security hazard
when used on the internet since any file accessible to the user can be
obtained by an attacker.


Multiple Request Handlers
-------------------------

Most web applications will rely on a `FileHandler` for delivering static
content such as static web pages, style sheets, and javascript files.
Only the dynamic part of the content is generated by custom request
handlers. This can be achieved by registering multiple request handler
objects with the central http server. Of course, now the http server
needs a way to decide which request will be handled by which handler.

This works as follows. Each request handler object (not the class, but
the specific instance) holds a list of patterns (string masks)
describing which requests it wants to handle. A mask can be a single,
static request, e.g., `/index.html`. This means that the handler is
willing to serve any request of this type, irrespective of possible
parameters. For example, the request
`http://127.0.0.1:8888/index.html?id=7` will be routed to this handler.
The handler's mask may include two types of wildcards, `*` and `?`.
These have the exact same meaning as in the file system: `*` represents
any sequence of characters including the empty sequence, and `?`
represents any single character. For example, a default FileHandler
object's pattern is simply `*`: it will accept all requests.

Now what if multiple handlers are willing to serve the same request?
Then the handler that was registered first to the http server gets to
handle the request. This implies a simple rule for request handler
registration: **always register the most specific handlers first!**
It is good practice to always register a single FileHandler last, so
all non-specific requests are assumed to requests static files::

  httpServer.registerHandler(new MyVerySpecificRequestHandler());
  httpServer.registerHandler(new MyRatherSpecificRequestHandler());
  httpServer.registerHandler(new MyBackupRequestHandler());
  httpServer.registerHandler(new FileHandler(rootdir));


Delivering Dynamic Content
--------------------------

Writing a custom request handler is easy. It is generally a customized
sub-class of `HttpServer::AbstractRequestHandler`. The class needs to do
two things: set the mask (or pattern) for which requests to handle, and
override the virtual function `handleRequest`. Here we see an example of
a request handler that delivers a dynamic content html page, containing
nothing but a random string::


  class RandomStringHandler : public HttpServer::AbstractRequestHandler
  {
  public:
    RandomStringHandler(std::string mask)
    : HttpServer::AbstractRequestHandler("RandomStringHandler")
    {
      m_pattern.push_back(mask);
    }

    void handleRequest(Connection& connection)
    {
      std::string str = "..........";
      for (int i=0; i<10; i++) str[i] = 'A' + (rand() % 26);
      std::string content = "<html><body><h1>" + std + "</h1></body></html>";
      connection.sendDocument(content, "text/html", 0);
    }
  };


Assume we register this handler as follows with our http server::

  httpServer.registerHandler(new RandomStringHandler("/randomstring"));

Register it first, since it is rather specific. Redirect the browser at
`http://127.0.0.1:8888/randomstring` and voila! A random string should
appear. Reload, the string should change. We have successfully delivered
dynamic content.

Sure, our content is dynamic, but until now the communication is quite
limited. So let's investigate the `connection` parameter of the
`handleRequest` method. The `Connection` object itself is a maintenance
unit of the http server. For example, it manages the underlying socket.
In the above example its `sendDocument` method is used to send a
document as a reply to the request to the browser, with MIME type
`text/html` and an expiry date `0` seconds into the future (which is a
good default for dynamic content). Alternatively we could have sent an
error code with the `sendError` method, e.g.::

  connection.sendError(400, "bad request: parameter X out of range");

One more maintenance task of the `Connection` class is to assemble and
hold the current http request::

  Request& request = connection.request();

The `Request` class knows about the request method (e.g., `GET` or
`POST`), the requested resource (e.g., `/index.html`), and the request
parameters (e.g., the tagged-value pair (`id`, `7`) in the request
`/index.html?id=7`). Although rarely needed, it even supports file
uploads.


An Example Involving Shark
--------------------------

Our final example in this tutorial connects the world of Shark with a
minimal browser GUI. The example is interactive. We will have a central
html file with a form as well as a custom request handler delivering
dynamic content. The example is rather artificial: we will display every
`N`-th data point of a `Data<RealVector>` object in a table, where `N`
is controlled by the user through a web page control.

We start with the file `index.html`::

  <html>
  <body>
  <form method="GET" action="/table" target="tab">
    Enter N here: <input type="TEXT" name="N" value="1" size="5" maxlength="5" />
    <input type="SUBMIT" value="GO!" />
  </form>
  <hr>
  <iframe name="tab" id="tab" width="800" height="500""></iframe>
  </body>
  </html>


The form on this page allows to enter the parameter `N` into a text
field. On clicking the GO! button a request with this parameter is sent
to the url `/table`, which can be handled by a specialized request
handler on the Shark/C++ side. The handler sends a reply, which is
redirected to the inline frame named `tab`. We handle the request in the
`DataTableHandler` class in the following C++ application::

  #include <SharkWebserver.h>
  #include <Dataset.h>
  #include <boost/thread/thread.hpp>
  #include <cinttypes>
  #include <sstream>

  using namespace shark;

  class DataTableHandler : public HttpServer::AbstractRequestHandler
  {
  public:
    DataTableHandler(Data<RealVector> data)
    : HttpServer::AbstractRequestHandler("DataTableHandler")
    , m_data(data)
    {
      m_pattern.push_back("/table");
    }

    void handleRequest(Connection& connection)
    {
      // parse parameter N
      std::string strN = connection.request()["N"];
      const char* cstrN = strN.c_str();
      char* end;
      long N = strtol(cstrN, &end, 10);
      if (*end != 0 || n <= 0) connection.sendError(400, "invalid parameter value: " + strN);
      else
      {
        // deliver dynamic table
        std::stringstream content;
        content << "<html><body style="background: #fec"><table>";
        long i = 0;
        Data<RealVector>::element_range elements = m_data.elements();
        for (Data<RealVector>::element_range::iterator pos = elements.begin(); pos != elements.end(); ++pos, ++i)
        {
          if ((i % N) == 0)    // skip all but every N-th entry
          {
            RealVector const& v = *pos;
            content << "<tr>";
            for (std::size_t i=0; i<v.size(); i++) content << "<td>" << v[i] << "</td>";
            content << "</tr>";
          }
        }
        content << "</table></body></html>";
        connection.sendDocument(content.str(), "text/html", 0);
      }
    }

  protected:
    Data<RealVector> m_data;
  };

  int main( int argc, char ** argv ) {
    // load data from comma separated value file
    Data<RealVector> data;
    import_csv(data, argv[1]);

    // prepare http server with custom and generic request handlers
    HttpServer httpServer;
    httpServer.registerHandler(new DataTableHandler());
    httpServer.registerHandler(new FileHandler(boost::filesystem::initial_path()));
    httpServer.run(8888);

    // start GUI in default browser
    openBrowser("http://127.0.0.1:8888/index.html");

    // wait...
    while (true) boost::this_thread::sleep( boost::posix_time::seconds(1) );
  }


Outlook
-------

You should have learned how to provide dynamic content to a html-based
GUI, delivered to the browser through Shark's own web server component.
Plain form-based html GUIs are very limited. However, they are often
sufficient in a machine learning context, and they are surely more
powerful than logfile and console output.

Next steps can go into different directions, all of which are beyond the
scope of this tutorial.

One obvious direction is to deliver custom images instead of web pages.
For example, a portable network graphics (PNG) image may be sent to the
client in the same way a web page is, but instead with MIME type
`image/png`. Of course, it makes sense to use a library for the task of
actually encoding a dynamically created bitmap into a compressed png
file on the fly.

Another direction is the creation of richer and more interactive GUIs
with better controls and AJAX-style updates instead of page reloads.
The best way to achieve this is one of the many javascript frameworks
out there.
